[CHUNK 2 OF 3]
BUNDLE_6_C_BRIDGE - PART 2
Concatenate all chunks in order to reconstruct.

f;
                float rotation = spiral_angle + base_rotation;
                
                int x = boss_x + (int)(cos(spiral_angle) * spiral_radius);
                int y = boss_y + (int)(sin(spiral_angle) * spiral_radius);
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 4: // Grid Formation - organized rectangular pattern
            int grid_size = (int)sqrt(num_components);
            for (int i = 0; i < num_components; i++) {
                int grid_x = i % grid_size;
                int grid_y = i / grid_size;
                int shape = (grid_x + grid_y + seed) % 5; // Pattern-based shapes
                int size = base_size + ((grid_x + grid_y) % 6) - 3;
                float shape_hue = boss_base_hue + ((grid_x + grid_y) * 0.12f);
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                float sat = 0.6f + ((grid_x * 7 + grid_y * 11) % 40) / 100.0f;
                float val = 0.7f + ((grid_x * 5 + grid_y * 13) % 30) / 100.0f;
                float rotation = base_rotation + (grid_x + grid_y) * 0.25f;
                
                int x = boss_x + (grid_x - grid_size/2) * 30;
                int y = boss_y + (grid_y - grid_size/2) * 30;
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 5: // Random Chaos Formation - completely random placement
            for (int i = 0; i < num_components; i++) {
                int shape = prng_range(&g_boss_prng, 5);
                int size = 10 + prng_range(&g_boss_prng, 30); // Wide size range
                float random_x = boss_x + prng_range(&g_boss_prng, 120) - 60; // ¬±60 pixel spread
                float random_y = boss_y + prng_range(&g_boss_prng, 120) - 60;
                float shape_hue = prng_range(&g_boss_prng, 100) / 100.0f; // Completely random hue
                float sat = 0.5f + prng_range(&g_boss_prng, 50) / 100.0f;
                float val = 0.6f + prng_range(&g_boss_prng, 40) / 100.0f;
                float rotation = prng_range(&g_boss_prng, 360) * M_PI / 180.0f;
                
                draw_boss_shape(random_x, random_y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 6: // Layered Formation - concentric circles of different shapes
            int layers = 1 + (num_components / 4);
            for (int layer = 0; layer < layers; layer++) {
                int shapes_in_layer = 3 + layer * 2;
                float layer_radius = 20 + layer * 25;
                for (int i = 0; i < shapes_in_layer && layer * shapes_in_layer + i < num_components; i++) {
                    float angle = (2.0f * M_PI * i) / shapes_in_layer;
                    int shape = (layer + i) % 5;
                    int size = base_size - layer * 3; // Smaller shapes in outer layers
                    float shape_hue = boss_base_hue + layer * 0.2f + i * 0.1f;
                    if (shape_hue > 1.0f) shape_hue -= 1.0f;
                    float sat = 0.8f - layer * 0.1f;
                    float val = 0.9f - layer * 0.1f;
                    float rotation = base_rotation + layer * 0.5f + i * 0.3f;
                    
                    int x = boss_x + (int)(cos(angle) * layer_radius);
                    int y = boss_y + (int)(sin(angle) * layer_radius);
                    draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
                }
            }
            break;
            
        case 7: // Pulsing Formation - sizes vary with audio and frame
            for (int i = 0; i < num_components; i++) {
                float pulse_phase = (i * 0.5f) + (frame * 0.08f);
                float pulse_factor = 0.7f + 0.3f * sin(pulse_phase) + audio_level * 0.4f;
                int shape = i % 5;
                int size = (int)(base_size * pulse_factor);
                float angle = (2.0f * M_PI * i) / num_components;
                float radius = 35 + sin(frame * 0.05f + i) * 15; // Varying radius
                float shape_hue = boss_base_hue + sin(pulse_phase) * 0.2f;
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                if (shape_hue < 0.0f) shape_hue += 1.0f;
                float sat = 0.7f + audio_level * 0.3f;
                float val = 0.8f + sin(pulse_phase) * 0.2f;
                float rotation = base_rotation + pulse_phase;
                
                int x = boss_x + (int)(cos(angle) * radius);
                int y = boss_y + (int)(sin(angle) * radius);
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
    }
}

int main(int argc, char *argv[]) {
    // CLI: <audio.wav> [seed_hex] [max_frames] [--pipe-ppm] [--range start end]
    bool pipe_ppm = false;
    int range_start = -1, range_end = -1;
    
    if (argc < 2 || argc > 8) {
        printf("üé¨ NotDeafBeef Frame Generator\n");
        printf("Usage: %s <audio_file.wav> [seed_hex] [max_frames] [--pipe-ppm] [--range start end]\n", argv[0]);
        printf("Example: %s audio.wav 0xDEADBEEF\n", argv[0]);
        printf("Example: %s audio.wav 0xDEADBEEF 24 --pipe-ppm  # Stream frames to stdout\n", argv[0]);
        printf("Example: %s audio.wav 0xDEADBEEF 0 --range 100 200  # Render frames 100-199\n", argv[0]);
        return 1;
    }
    
    // Parse flags and options
    int arg_idx = argc - 1;
    while (arg_idx >= 2) {
        if (strcmp(argv[arg_idx], "--pipe-ppm") == 0) {
            pipe_ppm = true;
            argc--;
            arg_idx--;
        } else if (strcmp(argv[arg_idx], "--range") == 0 && arg_idx >= 3) {
            // --range start end
            range_end = atoi(argv[arg_idx + 1]);
            range_start = atoi(argv[arg_idx]);
            argc -= 3; // Remove --range start end
            arg_idx -= 3;
        } else {
            break;
        }
    }

    printf("üé® Generating visual frames from audio: %s\n", argv[1]);
    
    // Load audio file
    if (!load_wav_file(argv[1])) {
        fprintf(stderr, "‚ùå Failed to load audio file: %s\n", argv[1]);
        return 1;
    }
    
    print_audio_info();
    
    // Initialize audio-visual mapping
    init_audio_visual_mapping();
    
    // Initialize visual systems with seed from audio
    uint32_t seed = 0xCAFEBABE; // Could be derived from audio file hash  
    
    // For testing: allow command line seed override
    if (argc >= 3) {
        // OPTIMIZATION: Hash long transaction hashes to 32-bit seeds
        seed = hash_transaction_to_seed(argv[2]);
        printf("üé≤ Using hashed seed: 0x%08X (from %s)\n", seed, argv[2]);
    }
    
    // Initialize PRNG streams
    init_visual_prng_streams(seed);
    
    // Allocate pixel buffer
    uint32_t *pixels = calloc(VIS_WIDTH * VIS_HEIGHT, sizeof(uint32_t));
    if (!pixels) {
        fprintf(stderr, "‚ùå Failed to allocate pixel buffer\n");
        return 1;
    }
    
    printf("üöÄ Initializing visual systems...\n");
    
    float base_hue = 0.5f;

    // Prefer timeline sidecar if present (<audio>.json) to drive visuals deterministically
    timeline_t tl = {0};
    char sidecar_path[512];
    snprintf(sidecar_path, sizeof(sidecar_path), "%s.json", argv[1]);
    bool have_timeline = timeline_load(sidecar_path, &tl);
    if (have_timeline) {
        printf("üß≠ Using timeline sidecar: %s\n", sidecar_path);
    } else {
        printf("‚ÑπÔ∏è  No timeline sidecar found (%s). Falling back to WAV analysis.\n", sidecar_path);
    }
    
    init_terrain_asm(seed, base_hue);
    // init_particles_asm(); // Removed for now
    init_glitch_system_asm(seed, 0.5f);
    init_bass_hits_asm();
    
    // Initialize second terrain system for top with different color
    uint32_t top_seed = seed ^ 0x12345678; // Different seed for variation
    float top_hue = base_hue + 0.3f; // Shift hue for different color
    if (top_hue > 1.0f) top_hue -= 1.0f; // Wrap around
    // We'll call init_terrain_asm again but we need a way to have two terrains
    
    printf("üé¨ Generating frames at 60 FPS...\n");
    
    int frame = 0;
    int total_frames = 0;
    
    // Calculate total frames needed (audio duration * FPS)
    // Get actual audio duration from loaded WAV file instead of hardcoded 5.0s
    float audio_duration = get_audio_duration(); // Use actual audio duration
    total_frames = (int)(audio_duration * VIS_FPS);
    
    // Allow frame limit override for quick testing
    if (argc == 4) {
        int max_frames = atoi(argv[3]);
        if (max_frames > 0 && max_frames < total_frames) {
            total_frames = max_frames;
            fprintf(pipe_ppm ? stderr : stdout, "üéØ Limiting to %d frames for quick test\n", total_frames);
        }
    }
    
    // Apply range filtering if specified
    int start_frame = 0;
    int end_frame = total_frames;
    if (range_start >= 0 && range_end >= 0) {
        if (range_start >= total_frames || range_end <= range_start) {
            fprintf(stderr, "‚ùå Invalid range: %d-%d (total frames: %d)\n", range_start, range_end, total_frames);
            return 1;
        }
        start_frame = range_start;
        end_frame = (range_end > total_frames) ? total_frames : range_end;
        fprintf(pipe_ppm ? stderr : stdout, "üéØ Rendering slice: frames %d-%d\n", start_frame, end_frame-1);
    }
    
    fprintf(pipe_ppm ? stderr : stdout,
            "üìΩÔ∏è  Total frames to generate: %d (%.1f seconds at %d FPS)\n",
            end_frame - start_frame, audio_duration, VIS_FPS);
    
    frame = start_frame; // Start from specified frame
    while (frame < end_frame && !is_audio_finished(frame)) {
        // Clear frame
        clear_frame_asm(pixels, 0x000000); // Black background
        
        // Set current pixels for shape drawing functions
        set_current_pixels(pixels);
        
        // Get audio-driven parameters (from sidecar if available)
        float audio_hue = have_timeline ? timeline_compute_hue(&tl, frame, VIS_FPS)
                                        : get_audio_driven_hue_shift(frame);
        float audio_level = have_timeline ? timeline_compute_level(&tl, frame, VIS_FPS)
                                          : get_smoothed_audio_level(frame);
        float glitch_intensity = have_timeline ? timeline_compute_glitch(&tl, frame, VIS_FPS)
                                               : get_audio_driven_glitch_intensity(frame);
        
        // Update workload budget based on current audio intensity
        update_workload_budget(audio_level);
        
        // Update audio-visual effects
        update_audio_visual_effects(frame, audio_hue);
        
        // Update glitch intensity
        update_glitch_intensity_asm(glitch_intensity);
        
        // Focus on terrain systems
        
        // Calculate different audio responses for each terrain
        float bottom_speed_multiplier = 1.0f + audio_level * 3.0f; // 1x to 4x speed
        float top_hue = audio_hue + 0.3f; // Different hue for top terrain
        if (top_hue > 1.0f) top_hue -= 1.0f;
        
        // Draw bottom terrain (enhanced system) - moderate speed with dynamic colors
        int bottom_frame = (int)(frame * bottom_speed_multiplier);
        draw_terrain_enhanced_asm(pixels, bottom_frame, audio_level);
        
        // Draw top terrain (new system) - different pattern and color
        draw_top_terrain(pixels, frame, top_hue, audio_level);
        
        // Update bass hits animation (needed for proper rendering)
        float elapsed_ms = frame * FRAME_TIME_MS;
        update_bass_hits_asm(elapsed_ms);
        
        // Budget-aware visual rendering - skip expensive elements on heavy frames
        if (g_budget.complexity_factor < 0.8f) {  // Only render complex elements when audio is not too intense
            // Draw ship flying through the corridor (pass seed for unique design)
            draw_ship(pixels, frame, audio_hue, audio_level, seed);
            
            // Draw enemy boss on the right side
            draw_enemy_boss(pixels, frame, audio_hue, audio_level, seed);
            
            // Update and draw projectiles (ship firing at boss)
            update_projectiles();
            draw_projectiles();
        } else {
            // High intensity - only update projectiles, don't render ship/boss
            update_projectiles();
            draw_projectiles();
        }
        
        // Draw the bass hits (this renders the ship and any other shapes)
        draw_bass_hits_asm(pixels, frame);
        
        // Output frame (with slice-aware naming)
        if (pipe_ppm) {
            write_frame_ppm(stdout, pixels);
        } else {
            // Include range info in filename for parallel slice rendering
            if (range_start >= 0 && range_end >= 0) {
                char filename[256];
                snprintf(filename, sizeof(filename), "frame_%04d_slice_%d_%d.ppm", frame, range_start, range_end-1);
                FILE *f = fopen(filename, "wb");
                if (!f) { fprintf(stderr, "Could not create %s\n", filename); return 1; }
                write_frame_ppm(f, pixels);
                fclose(f);
                fprintf(stderr, "‚úÖ Generated %s\n", filename);
            } else {
                save_frame_as_ppm(pixels, frame);
            }
        }
        
        // Progress indicator
        if (!pipe_ppm && frame % 30 == 0) {
            printf("üé¨ Frame %d/%d (%.1f%% complete)\n",
                   frame, end_frame, ((frame - start_frame) * 100.0f) / (end_frame - start_frame));
        } else if (pipe_ppm && frame % 120 == 0) {
            fprintf(stderr, "üé¨ Frame %d/%d (%.1f%%)\n",
                    frame, end_frame, ((frame - start_frame) * 100.0f) / (end_frame - start_frame));
        }
        
        frame++;
    }
    
    if (!pipe_ppm) {
        printf("üéâ Frame generation complete! Generated %d frames\n", frame - start_frame);
        if (range_start >= 0 && range_end >= 0) {
            printf("üìΩÔ∏è  Slice complete: frames %d-%d\n", range_start, range_end-1);
            printf("üìΩÔ∏è  To merge slices: use parallel_render_coordinator.sh\n");
        } else {
            printf("üìΩÔ∏è  To create video: ffmpeg -r 60 -i frame_%%04d.ppm -c:v libx264 -pix_fmt yuv420p output.mp4\n");
        }
    } else {
        fprintf(stderr, "üéâ Frame piping complete! Sent %d frames to stdout.\n", frame - start_frame);
        fprintf(stderr, "üí° Example: ./generate_frames audio.wav 0xSEED --pipe-ppm | ffmpeg -r 60 -f image2pipe -vcodec ppm -i - -i audio.wav -c:v libx264 -pix_fmt yuv420p -shortest output.mp4\n");
    }
    
    // Cleanup
    free(pixels);
    cleanup_audio_data();
    if (have_timeline) timeline_free(&tl);
    
    return 0;
}




---END---

=== FILE: simple_wav_reader.c ===
---BEGIN---
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// WAV file header structure
typedef struct {
    char riff[4];           // "RIFF"
    uint32_t chunk_size;    // File size - 8
    char wave[4];           // "WAVE"
    char fmt[4];            // "fmt "
    uint32_t fmt_size;      // Format chunk size
    uint16_t audio_format;  // Audio format (1 = PCM)
    uint16_t num_channels;  // Number of channels
    uint32_t sample_rate;   // Sample rate
    uint32_t byte_rate;     // Byte rate
    uint16_t block_align;   // Block align
    uint16_t bits_per_sample; // Bits per sample
    char data[4];           // "data"
    uint32_t data_size;     // Data size
} wav_header_t;

// Audio analysis data
typedef struct {
    int16_t *samples;       // Raw audio samples (stereo interleaved)
    uint32_t sample_count;  // Total samples (left + right)
    uint32_t frame_count;   // Number of stereo frames
    uint32_t sample_rate;   // Sample rate (Hz)
    float duration;         // Duration in seconds
} audio_data_t;

static audio_data_t audio_data = {0};

// Simple audio level calculation (RMS)
float calculate_audio_level_at_frame(int frame_number, float fps) {
    if (!audio_data.samples || audio_data.frame_count == 0) {
        return 0.2f; // Default level
    }
    
    float time_seconds = frame_number / fps;
    uint32_t sample_index = (uint32_t)(time_seconds * audio_data.sample_rate);
    
    if (sample_index >= audio_data.frame_count) {
        sample_index = audio_data.frame_count - 1;
    }
    
    // Calculate RMS over a small window
    uint32_t window_size = audio_data.sample_rate / 30; // ~33ms window
    uint32_t start_sample = (sample_index > window_size/2) ? sample_index - window_size/2 : 0;
    uint32_t end_sample = start_sample + window_size;
    if (end_sample > audio_data.frame_count) {
        end_sample = audio_data.frame_count;
        start_sample = (end_sample > window_size) ? end_sample - window_size : 0;
    }
    
    float sum_squares = 0.0f;
    uint32_t count = 0;
    
    for (uint32_t i = start_sample; i < end_sample; i++) {
        float left = audio_data.samples[i * 2] / 32768.0f;
        float right = audio_data.samples[i * 2 + 1] / 32768.0f;
        float mono = (left + right) * 0.5f;
        sum_squares += mono * mono;
        count++;
    }
    
    if (count == 0) return 0.2f;
    
    float rms = sqrtf(sum_squares / count);
    return fminf(1.0f, fmaxf(0.0f, rms * 3.0f)); // Scale and clamp
}

// Load WAV file
bool load_wav_file(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        printf("Failed to open WAV file: %s\n", filename);
        return false;
    }
    
    wav_header_t header;
    if (fread(&header, sizeof(header), 1, file) != 1) {
        printf("Failed to read WAV header\n");
        fclose(file);
        return false;
    }
    
    // Basic validation
    if (strncmp(header.riff, "RIFF", 4) != 0 || 
        strncmp(header.wave, "WAVE", 4) != 0 ||
        strncmp(header.data, "data", 4) != 0) {
        printf("Invalid WAV file format\n");
        fclose(file);
        return false;
    }
    
    if (header.audio_format != 1 || header.bits_per_sample != 16) {
        printf("Unsupported WAV format (need 16-bit PCM)\n");
        fclose(file);
        return false;
    }
    
    // Allocate and read sample data
    uint32_t sample_count = header.data_size / 2; // 16-bit samples
    audio_data.samples = malloc(header.data_size);
    if (!audio_data.samples) {
        printf("Failed to allocate memory for samples\n");
        fclose(file);
        return false;
    }
    
    if (fread(audio_data.samples, header.data_size, 1, file) != 1) {
        printf("Failed to read sample data\n");
        free(audio_data.samples);
        audio_data.samples = NULL;
        fclose(file);
        return false;
    }
    
    audio_data.sample_count = sample_count;
    audio_data.frame_count = sample_count / header.num_channels;
    audio_data.sample_rate = header.sample_rate;
    audio_data.duration = (float)audio_data.frame_count / header.sample_rate;
    
    fclose(file);
    
    printf("Loaded WAV: %d samples, %.2f seconds, %d Hz\n", 
           audio_data.frame_count, audio_data.duration, audio_data.sample_rate);
    
    return true;
}

// Additional functions needed by audio_visual_bridge.c
float get_audio_duration() {
    return audio_data.duration;
}

bool is_audio_finished() {
    return false; // For frame generation, never consider audio "finished"
}

void print_audio_info() {
    printf("Audio info: %.2f seconds, %d Hz, %d frames\n", 
           audio_data.duration, audio_data.sample_rate, audio_data.frame_count);
}

float get_audio_rms_for_frame(int frame_number, float fps) {
    return calculate_audio_level_at_frame(frame_number, fps);
}

float get_max_rms() {
    return 1.0f; // Assume normalized
}

float get_audio_bpm() {
    return 120.0f; // Default BPM
}

// Cleanup
void cleanup_audio_data() {
    if (audio_data.samples) {
        free(audio_data.samples);
        audio_data.samples = NULL;
    }
    audio_data.sample_count = 0;
    audio_data.frame_count = 0;
    audio_data.sample_rate = 0;
    audio_data.duration = 0.0f;
}

---END---

=== FILE: generate_nft.sh ===
---BEGIN---
#!/bin/bash

# generate_nft.sh - NotDeafBeef NFT Generation Pipeline
# Generates complete audio-visual NFT from Ethereum transaction hash
# 
# Usage: ./generate_nft.sh <tx_hash> [output_dir]
# Example: ./generate_nft.sh 0xDEADBEEF123456789ABCDEF output/

set -e  # Exit on any error

# Configuration
TX_HASH=${1:-"0xDEADBEEF"}
OUTPUT_DIR=${2:-"./nft_output"}
SEED="$TX_HASH"  # Use full transaction hash as seed
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
SCRIPT_DIR=$(pwd)  # Store script directory for absolute paths

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Validate inputs
if [ -z "$TX_HASH" ]; then
    error "Transaction hash required. Usage: $0 <tx_hash> [output_dir]"
fi

# Create output directory structure
mkdir -p "$OUTPUT_DIR"
mkdir -p "$OUTPUT_DIR/temp"

# File names
AUDIO_BASE="$OUTPUT_DIR/temp/${SEED}_base.wav"
AUDIO_LONG="$OUTPUT_DIR/${TX_HASH}_audio.wav"
VIDEO_FINAL="$OUTPUT_DIR/${TX_HASH}_final.mp4"
METADATA_FILE="$OUTPUT_DIR/${TX_HASH}_metadata.json"

log "üé® Starting NFT generation for transaction: $TX_HASH"
log "   Seed: $SEED"
log "   Output: $OUTPUT_DIR"

# Step 1: Generate base audio segment
log "üéµ Step 1: Generating base audio segment..."
cd src/c

# Build if necessary
if [ ! -f bin/segment ]; then
    log "   Building audio engine..."
    make segment USE_ASM=1 VOICE_ASM="GENERATOR_ASM KICK_ASM SNARE_ASM HAT_ASM MELODY_ASM LIMITER_ASM FM_VOICE_ASM" || error "Failed to build audio engine"
fi

# Generate base segment
log "   Synthesizing audio with seed $SEED..."
./bin/segment "$SEED" > /dev/null 2>&1

# Find generated file
SEGMENT_FILE=$(ls seed_0x*.wav 2>/dev/null | head -1)
if [ ! -f "$SEGMENT_FILE" ]; then
    error "Audio generation failed - no output file found"
fi

# Move to our naming convention
mv "$SEGMENT_FILE" "../../$AUDIO_BASE"
cd ../..

AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_BASE" 2>/dev/null)
success "Generated base audio: ${AUDIO_DURATION}s"

# Step 2: Create extended audio (6x concatenation ‚âà 25 seconds)
log "üîÑ Step 2: Creating extended audio track..."

# Create temp directory for concatenation
TEMP_CONCAT="$OUTPUT_DIR/temp/concat"
mkdir -p "$TEMP_CONCAT"

# Create 6 copies for concatenation
for i in {1..6}; do
    cp "$AUDIO_BASE" "$TEMP_CONCAT/segment_$i.wav"
done

# Concatenate with sox (fallback to ffmpeg if sox not available)
if command -v sox >/dev/null 2>&1; then
    log "   Using sox for concatenation..."
    sox "$TEMP_CONCAT"/segment_*.wav "$AUDIO_LONG" 2>/dev/null || error "Sox concatenation failed"
else
    log "   Using ffmpeg for concatenation..."
    # Create file list for ffmpeg
    for i in {1..6}; do
        echo "file '$TEMP_CONCAT/segment_$i.wav'" >> "$TEMP_CONCAT/filelist.txt"
    done
    ffmpeg -f concat -safe 0 -i "$TEMP_CONCAT/filelist.txt" -c copy "$AUDIO_LONG" -y >/dev/null 2>&1 || error "FFmpeg concatenation failed"
fi

EXTENDED_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_LONG" 2>/dev/null)
success "Created extended audio: ${EXTENDED_DURATION}s"

# Step 3: Generate visual frames
log "üñºÔ∏è  Step 3: Generating visual frames..."

# Build frame generator if needed
if [ ! -f generate_frames ]; then
    log "   Building frame generator..."
    make generate_frames || error "Failed to build frame generator"
fi

# Generate frames (change to output d