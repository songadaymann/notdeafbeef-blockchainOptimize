[CHUNK 1 OF 3]
BUNDLE_3_VISUAL_CORE - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_3_VISUAL_CORE]
=============================================================
Visual foundation: drawing, colors, ASCII rendering
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_3_visual_core
Total files: 5
Files included:
  - visual/visual_core.s (7786 bytes)
  - visual/drawing.s (6465 bytes)
  - visual/ascii_renderer.s (13930 bytes)
  - visual/particles.s (14916 bytes)
  - visual/glitch_system.s (19346 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: visual/visual_core.s ===
---BEGIN---
.section __TEXT,__text,regular,pure_instructions
.align 4

// ARM64 Assembly implementation of visual_core.c
// Following the proven methodology from audio engine development

// Constants for floating point operations
.align 4
constants:
float_255:      .float 255.0
float_6:        .float 6.0
float_1:        .float 1.0
float_0:        .float 0.0

//==============================================================================
// uint32_t color_to_pixel(color_t color)
//
// Convert RGBA color struct to 32-bit ARGB pixel
// x0: pointer to color_t struct (r,g,b,a as uint8_t)
// Returns: 32-bit pixel in w0 (ARGB format)
//==============================================================================
.global _color_to_pixel
_color_to_pixel:
    // Load all 4 bytes from color struct
    ldr w1, [x0]              // Load r,g,b,a as 32-bit word
    
    // Extract individual bytes
    ubfx w2, w1, #0, #8       // r = bits 0-7
    ubfx w3, w1, #8, #8       // g = bits 8-15  
    ubfx w4, w1, #16, #8      // b = bits 16-23
    ubfx w5, w1, #24, #8      // a = bits 24-31
    
    // Pack into ARGB format: (a << 24) | (r << 16) | (g << 8) | b
    lsl w5, w5, #24           // a << 24
    lsl w2, w2, #16           // r << 16
    lsl w3, w3, #8            // g << 8
    // b stays as-is (w4)
    
    orr w0, w5, w2            // a | r
    orr w0, w0, w3            // (a | r) | g
    orr w0, w0, w4            // (a | r | g) | b
    
    ret

//==============================================================================
// visual_mode_t get_visual_mode(int bpm)
//
// Determine visual mode based on BPM
// w0: BPM value
// Returns: visual_mode_t enum value in w0
//==============================================================================
.global _get_visual_mode
_get_visual_mode:
    // if (bpm < 70) return VIS_MODE_THICK (0)
    cmp w0, #70
    mov w1, #0                // VIS_MODE_THICK = 0
    b.lt .Lgvm_return
    
    // if (bpm < 100) return VIS_MODE_RINGS (1)  
    cmp w0, #100
    mov w1, #1                // VIS_MODE_RINGS = 1
    b.lt .Lgvm_return
    
    // if (bpm < 130) return VIS_MODE_POLY (2)
    cmp w0, #130
    mov w1, #2                // VIS_MODE_POLY = 2
    b.lt .Lgvm_return
    
    // else return VIS_MODE_LISSA (3)
    mov w1, #3                // VIS_MODE_LISSA = 3

.Lgvm_return:
    mov w0, w1
    ret

//==============================================================================
// color_t hsv_to_rgb(hsv_t hsv)
//
// Convert HSV to RGB color (most complex function)
// x0: pointer to hsv_t struct (h,s,v as float)
// x1: pointer to output color_t struct
//==============================================================================
.global _hsv_to_rgb
_hsv_to_rgb:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    stp s8, s9, [sp, #16]     // Save callee-saved SIMD registers
    
    // Load HSV values
    ldr s0, [x0]              // h
    ldr s1, [x0, #4]          // s  
    ldr s2, [x0, #8]          // v
    
    // Save output pointer
    mov x2, x1
    
    // Load constants
    adrp x3, constants@PAGE
    add x3, x3, constants@PAGEOFF
    ldr s3, [x3, #12]         // float_0 = 0.0
    ldr s4, [x3, #8]          // float_1 = 1.0  
    ldr s5, [x3, #4]          // float_6 = 6.0
    ldr s6, [x3]              // float_255 = 255.0
    
    // Normalize hue to [0, 1) using fmod equivalent
    // Since we don't have fmod in ASM, we'll implement h = h - floor(h)
    fcvtzs w4, s0             // w4 = (int)h (floor for positive numbers)
    scvtf s7, w4              // s7 = (float)w4
    fsub s0, s0, s7           // h = h - floor(h)
    
    // Handle negative hue
    fcmp s0, s3               // compare h with 0.0
    fadd s8, s0, s4           // s8 = h + 1.0
    fcsel s0, s8, s0, lt      // if h < 0, h = h + 1.0, else h = h
    
    // Clamp saturation to [0, 1]
    fmax s1, s1, s3           // s = max(s, 0.0)
    fmin s1, s1, s4           // s = min(s, 1.0)
    
    // Clamp value to [0, 1]  
    fmax s2, s2, s3           // v = max(v, 0.0)
    fmin s2, s2, s4           // v = min(v, 1.0)
    
    // Calculate sector: i = (int)(h * 6.0)
    fmul s7, s0, s5           // s7 = h * 6.0
    fcvtzs w4, s7             // w4 = i = (int)(h * 6.0)
    
    // Calculate fractional part: f = h * 6.0 - i
    scvtf s8, w4              // s8 = (float)i
    fsub s8, s7, s8           // s8 = f = h * 6.0 - i
    
    // Calculate intermediate values
    fsub s9, s4, s1           // s9 = 1.0 - s
    fmul s9, s2, s9           // p = v * (1.0 - s)
    
    fmul s10, s8, s1          // s10 = f * s
    fsub s11, s4, s10         // s11 = 1.0 - f * s
    fmul s10, s2, s11         // q = v * (1.0 - f * s)
    
    fsub s11, s4, s8          // s11 = 1.0 - f
    fmul s11, s11, s1         // s11 = (1.0 - f) * s
    fsub s11, s4, s11         // s11 = 1.0 - (1.0 - f) * s
    fmul s11, s2, s11         // t = v * (1.0 - (1.0 - f) * s)
    
    // Switch on sector (i % 6)
    mov w5, #6
    udiv w6, w4, w5           // w6 = i / 6
    msub w4, w6, w5, w4       // w4 = i % 6
    
    // Jump table for switch statement
    adr x5, .Lswitch_table
    ldr w6, [x5, w4, uxtw #2] // Load offset for case w4
    add x5, x5, w6, sxtw      // Add offset to base
    br x5                     // Jump to case
    
.Lswitch_table:
    .word .Lcase0 - .Lswitch_table
    .word .Lcase1 - .Lswitch_table
    .word .Lcase2 - .Lswitch_table
    .word .Lcase3 - .Lswitch_table
    .word .Lcase4 - .Lswitch_table
    .word .Lcase5 - .Lswitch_table

.Lcase0:  // r = v, g = t, b = p
    fmov s12, s2              // r = v
    fmov s13, s11             // g = t
    fmov s14, s9              // b = p
    b .Lconvert_to_bytes

.Lcase1:  // r = q, g = v, b = p
    fmov s12, s10             // r = q
    fmov s13, s2              // g = v
    fmov s14, s9              // b = p
    b .Lconvert_to_bytes

.Lcase2:  // r = p, g = v, b = t
    fmov s12, s9              // r = p
    fmov s13, s2              // g = v
    fmov s14, s11             // b = t
    b .Lconvert_to_bytes

.Lcase3:  // r = p, g = q, b = v
    fmov s12, s9              // r = p
    fmov s13, s10             // g = q
    fmov s14, s2              // b = v
    b .Lconvert_to_bytes

.Lcase4:  // r = t, g = p, b = v
    fmov s12, s11             // r = t
    fmov s13, s9              // g = p
    fmov s14, s2              // b = v
    b .Lconvert_to_bytes

.Lcase5:  // r = v, g = p, b = q
    fmov s12, s2              // r = v
    fmov s13, s9              // g = p
    fmov s14, s10             // b = q
    
.Lconvert_to_bytes:
    // Convert float [0,1] to uint8 [0,255]
    fmul s12, s12, s6         // r *= 255.0
    fmul s13, s13, s6         // g *= 255.0  
    fmul s14, s14, s6         // b *= 255.0
    
    // Convert to integers and clamp
    fcvtns w4, s12            // r as int (nearest)
    fcvtns w5, s13            // g as int  
    fcvtns w6, s14            // b as int
    
    // Clamp to [0, 255]
    mov w7, #255
    cmp w4, #0
    csel w4, wzr, w4, lt      // r = max(r, 0)
    cmp w4, w7
    csel w4, w7, w4, gt       // r = min(r, 255)
    
    cmp w5, #0  
    csel w5, wzr, w5, lt      // g = max(g, 0)
    cmp w5, w7
    csel w5, w7, w5, gt       // g = min(g, 255)
    
    cmp w6, #0
    csel w6, wzr, w6, lt      // b = max(b, 0)
    cmp w6, w7
    csel w6, w7, w6, gt       // b = min(b, 255)
    
    // Pack into color_t struct and store
    strb w4, [x2]             // store r
    strb w5, [x2, #1]         // store g
    strb w6, [x2, #2]         // store b
    mov w7, #255
    strb w7, [x2, #3]         // store a = 255
    
    // Return the color struct (x0 already contains return pointer)
    mov x0, x2
    
    ldp s8, s9, [sp, #16]     // Restore callee-saved SIMD registers
    ldp x29, x30, [sp], #32
    ret

---END---

=== FILE: visual/drawing.s ===
---BEGIN---
.section __TEXT,__text,regular,pure_instructions
.align 4

// ARM64 Assembly implementation of drawing.c
// Starting with simple functions following proven methodology

// Constants
.align 4
drawing_constants:
vis_width:      .word 800
vis_height:     .word 600

//==============================================================================
// static void set_pixel(uint32_t *pixels, int x, int y, uint32_t color)
//
// Set a pixel with bounds checking
// x0: pixels buffer pointer
// w1: x coordinate  
// w2: y coordinate
// w3: color (32-bit)
//==============================================================================
.global _set_pixel_asm
_set_pixel_asm:
    // Bounds check: x >= 0 && x < VIS_WIDTH
    cmp w1, #0
    b.lt .Lsp_return          // if x < 0, return
    cmp w1, #800              // VIS_WIDTH
    b.ge .Lsp_return          // if x >= 800, return
    
    // Bounds check: y >= 0 && y < VIS_HEIGHT  
    cmp w2, #0
    b.lt .Lsp_return          // if y < 0, return
    cmp w2, #600              // VIS_HEIGHT
    b.ge .Lsp_return          // if y >= 600, return
    
    // Calculate offset: pixels[y * VIS_WIDTH + x]
    mov w4, #800              // VIS_WIDTH
    mul w5, w2, w4            // y * VIS_WIDTH
    add w5, w5, w1            // y * VIS_WIDTH + x
    
    // Store color at calculated offset
    str w3, [x0, w5, uxtw #2] // pixels[offset] = color (4 bytes per pixel)
    
.Lsp_return:
    ret

//==============================================================================
// void clear_frame(uint32_t *pixels, uint32_t color)
//
// Clear entire frame buffer with specified color
// x0: pixels buffer pointer
// w1: color (32-bit)
//==============================================================================
.global _clear_frame_asm
_clear_frame_asm:
    // Calculate total pixels: VIS_WIDTH * VIS_HEIGHT = 800 * 600 = 480,000
    mov w2, #800              // VIS_WIDTH
    mov w3, #600              // VIS_HEIGHT  
    mul w2, w2, w3            // total pixels
    
    // Use NEON for faster clearing (process 4 pixels at a time)
    dup v0.4s, w1             // Duplicate color into 4 lanes
    
    // Main loop: clear 4 pixels at a time
    mov w3, #0                // counter
.Lcf_loop:
    cmp w3, w2                // compare counter with total
    b.ge .Lcf_done            // if counter >= total, done
    
    // Check if we can process 4 pixels safely
    sub w4, w2, w3            // remaining pixels
    cmp w4, #4
    b.lt .Lcf_single          // if less than 4 remaining, do single pixels
    
    // Store 4 pixels using NEON (calculate byte offset manually)
    lsl x4, x3, #2            // Convert pixel index to byte offset (64-bit)
    str q0, [x0, x4]          // Store 16 bytes (4 pixels)
    add w3, w3, #4            // increment counter by 4
    b .Lcf_loop
    
.Lcf_single:
    // Handle remaining pixels one by one
    cmp w3, w2
    b.ge .Lcf_done
    str w1, [x0, w3, uxtw #2] // Store single pixel
    add w3, w3, #1
    b .Lcf_single
    
.Lcf_done:
    ret

//==============================================================================
// void draw_circle_filled(uint32_t *pixels, int cx, int cy, int radius, uint32_t color)
//
// Draw a filled circle using simple algorithm
// x0: pixels buffer pointer
// w1: center x
// w2: center y  
// w3: radius
// w4: color
//==============================================================================
.global _draw_circle_filled_asm
_draw_circle_filled_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    stp w19, w20, [sp, #16]   // Save callee-saved registers
    stp w21, w22, [sp, #20]
    stp w23, w24, [sp, #24]
    
    // Save parameters
    mov x19, x0               // pixels
    mov w20, w1               // cx
    mov w21, w2               // cy
    mov w22, w3               // radius
    mov w23, w4               // color
    
    // Outer loop: y from -radius to +radius
    neg w24, w22              // y = -radius
    
.Ldcf_y_loop:
    cmp w24, w22              // compare y with radius
    b.gt .Ldcf_done           // if y > radius, done
    
    // Inner loop: x from -radius to +radius
    neg w25, w22              // x = -radius
    
.Ldcf_x_loop:
    cmp w25, w22              // compare x with radius
    b.gt .Ldcf_y_next         // if x > radius, next y
    
    // Check if point is inside circle: x*x + y*y <= radius*radius
    mul w26, w25, w25         // x * x
    mul w27, w24, w24         // y * y  
    add w26, w26, w27         // x*x + y*y
    mul w27, w22, w22         // radius * radius
    cmp w26, w27              // compare x*x + y*y with radius*radius
    b.gt .Ldcf_x_next         // if outside circle, skip
    
    // Point is inside circle, draw pixel
    add w1, w20, w25          // pixel_x = cx + x
    add w2, w21, w24          // pixel_y = cy + y
    mov x0, x19               // pixels buffer
    mov w3, w23               // color
    bl _set_pixel_asm         // call set_pixel_asm
    
.Ldcf_x_next:
    add w25, w25, #1          // x++
    b .Ldcf_x_loop
    
.Ldcf_y_next:
    add w24, w24, #1          // y++
    b .Ldcf_y_loop
    
.Ldcf_done:
    ldp w23, w24, [sp, #24]   // Restore callee-saved registers
    ldp w21, w22, [sp, #20]
    ldp w19, w20, [sp, #16]
    ldp x29, x30, [sp], #32
    ret

//==============================================================================
// uint32_t circle_color(float base_hue, float saturation, float value)
//
// Helper function to create circle color with hue variation
// s0: base_hue
// s1: saturation
// s2: value
// Returns: color in w0
//==============================================================================
.global _circle_color_asm
_circle_color_asm:
    stp x29, x30, [sp, #-48]!
    mov x29, sp
    
    // Create HSV struct on stack at [sp, #16] (12 bytes: 3 floats)
    str s0, [sp, #16]         // h at [sp, #16]
    str s1, [sp, #20]         // s at [sp, #20] 
    str s2, [sp, #24]         // v at [sp, #24]
    
    // Call hsv_to_rgb
    add x0, sp, #16           // pointer to HSV struct on stack
    add x1, sp, #32           // pointer to output color_t on stack (4 bytes: r,g,b,a)
    bl _hsv_to_rgb            // Call the existing HSV to RGB function
    
    // Call color_to_pixel
    add x0, sp, #32           // pointer to color_t struct
    bl _color_to_pixel        // Call the existing color to pixel function
    
    // Return value already in w0
    ldp x29, x30, [sp], #48
    ret

---END---

=== FILE: visual/ascii_renderer.s ===
---BEGIN---
//==============================================================================
// ASCII Renderer - ARM64 Assembly Implementation
//
// Port of ascii_renderer.c to pure ARM64 assembly
// Functions for bitmap font rendering
//==============================================================================

.text
.align 4

//==============================================================================
// Constants
//==============================================================================
ascii_constants:
char_width:     .word 8
char_height:    .word 8 
vis_width:      .word 800
vis_height:     .word 600

//==============================================================================
// ASCII Font Data - 8x8 bitmap font
// Each character uses 2 uint32 values (64 bits total)
// 256 characters arranged in 16x16 grid
//==============================================================================
.align 4
ascii_font:
    // Character row 0 (chars 0-15)
    .word 0x00000000, 0x00000000  // char 0 0x00
    .word 0x00000000, 0x00000000  // char 1 0x01
    .word 0x00000000, 0x00000000  // char 2 0x02
    .word 0x00000000, 0x00000000  // char 3 0x03
    .word 0x00000000, 0x00000000  // char 4 0x04
    .word 0x00000000, 0x00000000  // char 5 0x05
    .word 0x00000000, 0x00000000  // char 6 0x06
    .word 0x00000000, 0x00000000  // char 7 0x07
    .word 0x00000000, 0x00000000  // char 8 0x08
    .word 0x00000000, 0x00000000  // char 9 0x09
    .word 0x00000000, 0x00000000  // char 10 0x0a
    .word 0x00000000, 0x00000000  // char 11 0x0b
    .word 0x00000000, 0x00000000  // char 12 0x0c
    .word 0x00000000, 0x00000000  // char 13 0x0d
    .word 0x00000000, 0x00000000  // char 14 0x0e
    .word 0x00000000, 0x00000000  // char 15 0x0f
    
    // Character row 1 (chars 16-31)
    .word 0x00000000, 0x00000000  // char 16 0x10
    .word 0x00000000, 0x00000000  // char 17 0x11
    .word 0x00000000, 0x00000000  // char 18 0x12
    .word 0x00000000, 0x00000000  // char 19 0x13
    .word 0x00000000, 0x00000000  // char 20 0x14
    .word 0x00000000, 0x00000000  // char 21 0x15
    .word 0x00000000, 0x00000000  // char 22 0x16
    .word 0x00000000, 0x00000000  // char 23 0x17
    .word 0x00000000, 0x00000000  // char 24 0x18
    .word 0x00000000, 0x00000000  // char 25 0x19
    .word 0x00000000, 0x00000000  // char 26 0x1a
    .word 0x00000000, 0x00000000  // char 27 0x1b
    .word 0x00000000, 0x00000000  // char 28 0x1c
    .word 0x00000000, 0x00000000  // char 29 0x1d
    .word 0x00000000, 0x00000000  // char 30 0x1e
    .word 0x00000000, 0x00000000  // char 31 0x1f
    
    // Character row 2 (chars 32-47) - Basic symbols
    .word 0x00000000, 0x00000000  // char 32 ' ' space
    .word 0x00000000, 0x00000000  // char 33 '!' 
    .word 0x00000000, 0x00000000  // char 34 '"'
    .word 0x24247e24, 0x0000247e  // char 35 '#' hash
    .word 0x00000000, 0x00000000  // char 36 '$'
    .word 0x00000000, 0x00000000  // char 37 '%'
    .word 0x00000000, 0x00000000  // char 38 '&'
    .word 0x00000000, 0x00000000  // char 39 '\''
    .word 0x00000000, 0x00000000  // char 40 '('
    .word 0x00000000, 0x00000000  // char 41 ')'
    .word 0x7c284400, 0x00004428  // char 42 '*' asterisk
    .word 0x7c101000, 0x00001010  // char 43 '+' plus
    .word 0x00000000, 0x00000000  // char 44 ','
    .word 0x7c000000, 0x00000000  // char 45 '-' minus
    .word 0x00000000, 0x00000000  // char 46 '.'
    .word 0x10080402, 0x00804020  // char 47 '/' slash
    
    // Character row 3 (chars 48-63) - Numbers and symbols
    .word 0x42424242, 0x007e4242  // char 48 '0'
    .word 0x42424242, 0x007e4242  // char 49 '1'
    .word 0x42424242, 0x007e4242  // char 50 '2'
    .word 0x42424242, 0x007e4242  // char 51 '3'
    .word 0x42424242, 0x007e4242  // char 52 '4'
    .word 0x42424242, 0x007e4242  // char 53 '5'
    .word 0x42424242, 0x007e4242  // char 54 '6'
    .word 0x42424242, 0x007e4242  // char 55 '7'
    .word 0x42424242, 0x007e4242  // char 56 '8'
    .word 0x42424242, 0x007e4242  // char 57 '9'
    .word 0x00000000, 0x00000000  // char 58 ':'
    .word 0x00000000, 0x00000000  // char 59 ';'
    .word 0x20100800, 0x00000810  // char 60 '<' less than
    .word 0x007c0000, 0x0000007c  // char 61 '=' equals
    .word 0x08102000, 0x00002010  // char 62 '>' greater than
    .word 0x00000000, 0x00000000  // char 63 '?'
    
    // Character row 4 (chars 64-79) - @ and uppercase letters A-O
    .word 0x00000000, 0x00000000  // char 64 '@'
    .word 0x4242427e, 0x007e4242  // char 65 'A'
    .word 0x4242427e, 0x007e4242  // char 66 'B'
    .word 0x4242427e, 0x007e4242  // char 67 'C'
    .word 0x4242427e, 0x007e4242  // char 68 'D'
    .word 0x4242427e, 0x007e4242  // char 69 'E'
    .word 0x4242427e, 0x007e4242  // char 70 'F'
    .word 0x4242427e, 0x007e4242  // char 71 'G'
    .word 0x4242427e, 0x007e4242  // char 72 'H'
    .word 0x4242427e, 0x007e4242  // char 73 'I'
    .word 0x4242427e, 0x007e4242  // char 74 'J'
    .word 0x4242427e, 0x007e4242  // char 75 'K'
    .word 0x4242427e, 0x007e4242  // char 76 'L'
    .word 0x4242427e, 0x007e4242  // char 77 'M'
    .word 0x4242427e, 0x007e4242  // char 78 'N'
    .word 0x4242427e, 0x007e4242  // char 79 'O'
    
    // Character row 5 (chars 80-95) - Letters P-Z and brackets
    .word 0x4242427e, 0x007e4242  // char 80 'P'
    .word 0x4242427e, 0x007e4242  // char 81 'Q'
    .word 0x4242427e, 0x007e4242  // char 82 'R'
    .word 0x4242427e, 0x007e4242  // char 83 'S'
    .word 0x4242427e, 0x007e4242  // char 84 'T'
    .word 0x4242427e, 0x007e4242  // char 85 'U'
    .word 0x4242427e, 0x007e4242  // char 86 'V'
    .word 0x4242427e, 0x007e4242  // char 87 'W'
    .word 0x4242427e, 0x007e4242  // char 88 'X'
    .word 0x4242427e, 0x007e4242  // char 89 'Y'
    .word 0x4242427e, 0x007e4242  // char 90 'Z'
    .word 0x4040407c, 0x007c4040  // char 91 '[' left bracket
    .word 0x10204080, 0x00020408  // char 92 '\' backslash
    .word 0x0404047c, 0x007c0404  // char 93 ']' right bracket
    .word 0x44281000, 0x00000000  // char 94 '^' caret
    .word 0x00000000, 0x007c0000  // char 95 '_' underscore
    
    // Character row 6 (chars 96-111) - lowercase and more symbols
    .word 0x00000000, 0x00000000  // char 96 '`'
    .word 0x00000000, 0x00000000  // char 97 'a'
    .word 0x00000000, 0x00000000  // char 98 'b'
    .word 0x00000000, 0x00000000  // char 99 'c'
    .word 0x00000000, 0x00000000  // char 100 'd'
    .word 0x00000000, 0x00000000  // char 101 'e'
    .word 0x00000000, 0x00000000  // char 102 'f'
    .word 0x00000000, 0x00000000  // char 103 'g'
    .word 0x00000000, 0x00000000  // char 104 'h'
    .word 0x00000000, 0x00000000  // char 105 'i'
    .word 0x00000000, 0x00000000  // char 106 'j'
    .word 0x00000000, 0x00000000  // char 107 'k'
    .word 0x00000000, 0x00000000  // char 108 'l'
    .word 0x00000000, 0x00000000  // char 109 'm'
    .word 0x00000000, 0x00000000  // char 110 'n'
    .word 0x00000000, 0x00000000  // char 111 'o'
    
    // Character row 7 (chars 112-127) - more lowercase and special chars
    .word 0x00000000, 0x00000000  // char 112 'p'
    .word 0x00000000, 0x00000000  // char 113 'q'
    .word 0x00000000, 0x00000000  // char 114 'r'
    .word 0x00000000, 0x00000000  // char 115 's'
    .word 0x00000000, 0x00000000  // char 116 't'
    .word 0x00000000, 0x00000000  // char 117 'u'
    .word 0x00000000, 0x00000000  // char 118 'v'
    .word 0x00000000, 0x00000000  // char 119 'w'
    .word 0x00000000, 0x00000000  // char 120 'x'
    .word 0x00000000, 0x00000000  // char 121 'y'
    .word 0x00000000, 0x00000000  // char 122 'z'
    .word 0x4020201c, 0x001c2020  // char 123 '{' left brace
    .word 0x10101010, 0x00101010  // char 124 '|' pipe
    .word 0x04080870, 0x00700808  // char 125 '}' right brace
    .word 0x004c3200, 0x00000000  // char 126 '~' tilde
    .word 0x00000000, 0x00000000  // char 127

    // Rows 8-15 (chars 128-255) - Extended ASCII filled with blanks
    .rept 128
    .word 0x00000000, 0x00000000
    .endr

//==============================================================================
// void draw_ascii_char_asm(uint32_t *pixels, int x, int y, char c, uint32_t color, int alpha)
//
// Draw a single ASCII character at position with color and alpha blending
// x0: pixels buffer
// w1: x position  
// w2: y position
// w3: character (char c)
// w4: color (uint32_t)
// w5: alpha (int, 0-255)
//==============================================================================
.global _draw_ascii_char_asm
_draw_ascii_char_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    
    // Save callee-saved registers with proper non-overlapping offsets
    stp x19, x20, [sp, #16]    // 16-31
    stp x21, x22, [sp, #32]    // 32-47  
    stp x23, x24, [sp, #48]    // 48-63
    stp x25, x26, [sp, #64]    // 64-79
    stp x27, x28, [sp, #80]    // 80-95
    
    // Store parameters in callee-saved registers
    mov x19, x0               // pixels buffer
    mov w20, w1               //