[CHUNK 1 OF 2]
BUNDLE_1_GENERATOR - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_1_GENERATOR]
=============================================================
Main audio generator (large file)
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_1_generator
Total files: 1
Files included:
  - audio/generator.s (34206 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: audio/generator.s ===
---BEGIN---
	.text
	.align 2
	.globl _generator_mix_buffers_asm

// Assembly stubs – we override only generator_process; keep C generator_init
	.globl _generator_process
	// (no _generator_init symbol here; C version remains)

_generator_process:
	// Args: x0 = g, x1 = L, x2 = R, w3 = num_frames

	// Prologue – save frame pointer & callee-saved regs (x19-x22)
	stp x29, x30, [sp, #-128]!   // reserve 128-byte fixed frame (was 96)
	mov x29, sp
	stp x19, x20, [sp, #16]
	stp x21, x22, [sp, #32]
	stp x23, x24, [sp, #48]
	stp x25, x26, [sp, #64]
	stp x27, x28, [sp, #80]

	// Early exit if no frames
	cbz w3, .Lgp_epilogue

	// Preserve output buffer pointers before we repurpose argument regs
	mov x19, x1            // L
	mov x20, x2            // R
	mov x24, x0            // g pointer
	// (dup line removed)
	// (generator pointer already preserved earlier)

	// Preserve num_frames in callee-saved x21 for later reuse
	mov x21, x3            // x21 = num_frames (32-bit valid)

	// ---------------------------------------------------------------------
	// Allocate contiguous scratch block on heap instead of stack
	// scratch_size = (num_frames * 16 + 15) & ~15      // 16-byte alignment
	lsl x22, x21, #4       // x22 = num_frames * 16  (bytes for 4 buffers)
	add x22, x22, #15
	bic x22, x22, #15      // align to 16 bytes

	// malloc(scratch_size)
	mov x0, x22
	bl _malloc
	mov x25, x0            // x25 = Ld base (scratch start)
	
	// TEMP: Check if malloc failed
	cbz x25, .Lgp_epilogue  // if malloc returned NULL, exit immediately

	// bytes_per_buffer = num_frames * 4
	lsl x5, x21, #2        // x5 = bytes per buffer

	// Compute remaining scratch pointers
	add x26, x25, x5       // Rd = Ld + size
	add x27, x26, x5       // Ls
	add x28, x27, x5       // Rs

	// Prepare arguments for generator_clear_buffers_asm
	mov x0, x25            // Ld
	add x1, x0, x5         // Rd = Ld + bytes_per_buffer
	add x2, x1, x5         // Ls
	add x3, x2, x5         // Rs
	mov w4, w21            // num_frames

	stp x21, x22, [sp, #96]     // save frames_rem & x22 inside fixed frame
	bl _generator_clear_buffers_asm
	ldp x21, x22, [sp, #96]     // restore w21, x22 (sp unchanged)

	// ---------------------------------------------------------------------
	// Skip explicit memset on L/R since they will be fully overwritten by
	// subsequent processing/mixing.

	// ---------------------------------------------------------------------
	// Slice-2: Outer frame loop over musical steps (state advance only)

	// Register assignments:
	//   x24 = g (generator*) – set now
	// Use x10 as pointer to timing/event fields (base = g + 4352)
	add x10, x24, #0x1000    // x10 = g + 4096
	add x10, x10, #0x128     // +296 => g + 4392 (event_idx)

	ldr w9, [x24, #12]      // w9 = step_samples (offset 12 bytes)
	ldr w8, [x10, #8]       // w8 = pos_in_step (event base + 8)

	// TOTAL_STEPS constant
	mov w13, #32           // for wrap-around comparison

	// After generator_clear_buffers_asm call and before outer loop label
	// Save scratch base pointers for later voice processing
	// x25..x28 already set to scratch pointers
	
	mov w23, wzr            // frames_done = 0 (will live in w23/x23)

.Lgp_loop:
	ldr w9, [x24, #12]           // reload step_samples each iteration
	cbz w21, .Lgp_after_loop      // frames_rem == 0 ? done

	// ----- DEBUG: dump counters at loop start -----
.if 0
	stp x0, x1, [sp, #-16]!   // save caller-saved regs we'll clobber
	stp x2, x3, [sp, #-16]!
	adrp x0, .Ldbg_pre_fmt@PAGE
	add  x0, x0, .Ldbg_pre_fmt@PAGEOFF
	mov  w1, w21   // frames_rem
	mov  w2, w9    // step_samples
	mov  w3, w8    // pos_in_step
	bl   _printf
	ldp x2, x3, [sp], #16      // restore
	ldp x0, x1, [sp], #16      // restore
.endif
	// ---------------------------------------------

	// Slice-3: Trigger events at step start
	cbnz w8, .Lgp_trigger_skip                   // Only trigger when pos_in_step == 0
	// Preserve caller-saved x8/x9 that hold pos_in_step & scratch before calling C helper
	stp x8, x9, [sp, #112]        // save into fixed 128-byte frame (offsets 112-127)
	mov x0, x24                   // x0 = g pointer
	bl _generator_trigger_step
	ldp x8, x9, [sp, #112]        // restore registers (keeps sp constant)

.Lgp_trigger_skip:
	// Recompute event/state base pointer after external calls may clobber x10
	add x10, x24, #0x1000
	add x10, x10, #0x128    // x10 = &g->event_idx
	ldr w9, [x24, #12]

	// Reload constant step_samples in case caller-saved w9 was clobbered
	ldr w9, [x24, #12]           // w9 = step_samples (offset 12 bytes)
	// frames_to_step_boundary = step_samples - pos_in_step
	sub w10, w9, w8              // w10 = frames_to_step_boundary  (no slice-shortening)
	// FM sustain fix: if pos_in_step == 0 and frames_to_step_boundary > 1, decrement by 1 so
	// that voices (particularly fm_voice) spread notes over at least two slices. This mirrors
	// the logic added in generator.c (Round 23 fix).
	cbnz w8, 1f                 // if pos_in_step != 0, skip
	cmp  w10, #1
	ble 1f                      // if boundary <=1, nothing to shorten
	sub  w10, w10, #1           // frames_to_step_boundary -= 1
1:
	// frames_to_process = min(frames_rem, frames_to_step_boundary)
	cmp w21, w10
	b.lt 1f
	mov w11, w10
	b 2f
1:	mov w11, w21
2:
	// ---------- Slice-4: Voice processing + mixing ----------
	// Save frames_to_process into callee-saved x22 to survive C call (zero-extend to avoid garbage high bits)
	mov w22, w11               // preserve w11, zeroing upper 32 bits of x22

	// Compute byte offset into scratch/output for frames_done
	lsl x12, x23, #2            // x12 = frames_done * 4 (bytes)

	// Scratch pointers for this sub-block
	add x13, x25, x12           // Ld ptr
	add x14, x26, x12           // Rd ptr
	add x15, x27, x12           // Ls ptr
	add x16, x28, x12           // Rs ptr
	// Output pointers
	add x17, x19, x12           // L dest
	add x18, x20, x12           // R dest

	// Call voice processor (preserve x21 across call)
	stp x21, x22, [sp, #96]     // save frames_rem & x22 inside fixed frame

	// Replace C voice processing with ASM voice processing calls
	
	// Process kick into drum buffers (Ld/Rd)
	add x0, x24, #56            // kick offset (from generator_t)
	mov x1, x13                 // Ld
	mov x2, x14                 // Rd
	mov w3, w11                 // num_frames
	bl _kick_process
	
	// Remove debug for now - focus on testing audio output
	
	// Process snare into drum buffers
	add x0, x24, #96            // snare offset
	mov x1, x13                 // Ld
	mov x2, x14                 // Rd
	mov w3, w11                 // num_frames
	bl _snare_process
	
	// Process melody into synth buffers (Ls/Rs)  
	add x0, x24, #160           // melody offset
	mov x1, x15                 // Ls
	mov x2, x16                 // Rs
	mov w3, w11                 // num_frames
	bl _melody_process
	
	// Process FM voices into synth buffers
	add x0, x24, #180           // mid_fm offset
	mov x1, x15                 // Ls
	mov x2, x16                 // Rs
	mov w3, w11                 // num_frames
	bl _fm_voice_process
	
	add x0, x24, #220           // bass_fm offset
	mov x1, x15                 // Ls
	mov x2, x16                 // Rs
	mov w3, w11                 // num_frames
	bl _fm_voice_process

	ldp x21, x22, [sp, #96]     // restore w21, x22 (sp unchanged)

	// Recompute event/state base pointer after _generator_process_voices (x10 may be clobbered)
	add x10, x24, #0x1000
	add x10, x10, #0x128    // x10 = &g->event_idx

	// Restore w11 from x22 after helper
	mov w11, w22               // restore frames_to_process
	// Reload pos_in_step since w8 is caller-clobbered
	ldr w8, [x10, #8]

    // ----- TRACE1: after voice processing -----
.if 0
    stp x0, x1, [sp, #-16]!   // save regs clobbered by printf
    adrp x0, .Ldbg_post1_fmt@PAGE
    add  x0, x0, .Ldbg_post1_fmt@PAGEOFF
    mov  w1, w21   // frames_rem (remaining)
    mov  w2, w11   // frames_to_process for this slice
    mov  w3, w8    // current pos_in_step
    bl   _printf
    ldp x0, x1, [sp], #16      // restore regs
.endif

	// TEMP: Remove offset calculation to test if that's the issue
	lsl x12, x23, #2            // byte offset = frames_done * 4
	add x13, x25, x12           // Ld ptr
	add x14, x26, x12           // Rd ptr
	add x15, x27, x12           // Ls ptr
	add x16, x28, x12           // Rs ptr
	add x17, x19, x12           // L dest = L_base + offset
	add x18, x20, x12           // R dest = R_base + offset

	// Mix drums + synths into output buffers
	mov x0, x17                 // L out
	mov x1, x18                 // R out
	mov x2, x13                 // Ld
	mov x3, x14                 // Rd
	mov x4, x15                 // Ls
	mov x5, x16                 // Rs
	mov w6, w11                 // num_frames
	// Just call the mixing function (debug later)
	bl _generator_mix_buffers_asm

	// Re-enable debug check but only for first slice
	.if 0
		cbnz w23, .Lskip_output_check    // only when frames_done == 0
		// cbnz w23, .Lskip_output_check    // DISABLED: run on every slice
		
		// Check first few samples of L output buffer as integers (simpler)
		ldr w0, [x17]      // Load L[0] as int
		ldr w1, [x17, #4]  // Load L[1] as int 
		ldr w2, [x17, #8]  // Load L[2] as int
		
		// Simple check: if any sample != 0, we have audio
		orr w0, w0, w1     // w0 = L[0] | L[1]
		orr w0, w0, w2     // w0 = L[0] | L[1] | L[2]
		cbnz w0, .Loutput_has_audio
		
		// Output is silent
		adrp x0, .Loutput_silent_msg@PAGE
		add x0, x0, .Loutput_silent_msg@PAGEOFF
		mov w1, #22
		mov x2, #2  // stderr
		mov x16, #4  // sys_write
		svc #0x80
		b .Lskip_output_check
		
	.Loutput_has_audio:
		adrp x0, .Loutput_audio_msg@PAGE
		add x0, x0, .Loutput_audio_msg@PAGEOFF
		mov w1, #24
		mov x2, #2  // stderr
		mov x16, #4  // sys_write
		svc #0x80
		
	.Lskip_output_check:
	.endif

	// ----- SCRATCH RMS PROBE (debug – first slice only) -----
	.if 0
		cbnz w23, .Lskip_scratch_rms    // only when frames_done == 0

		// Save caller-saved regs we will clobber (x0-x3)
		stp x0, x1, [sp, #-16]!
		stp x2, x3, [sp, #-16]!

		// ---- drums scratch RMS (Ld/Rd) ----
		mov x0, x13      // Ld
		mov x1, x14      // Rd
		mov w2, w11      // num_frames in slice
		bl  _generator_compute_rms_asm   // s0 = RMS
		fmov w4, s0                      // raw bits -> w4

		// ---- synth scratch RMS (Ls/Rs) ----
		mov x0, x15      // Ls
		mov x1, x16      // Rs
		mov w2, w11
		bl  _generator_compute_rms_asm   // s0 = RMS
		fmov w5, s0                      // raw bits -> w5

		// printf("SCR drums=%u synth=%u n=%u\n", drums_bits, synth_bits, frames_to_process)
		adrp x0, .Ldbg_scratch_fmt@PAGE
		add  x0, x0, .Ldbg_scratch_fmt@PAGEOFF
		mov  w1, w4
		mov  w2, w5
		mov  w3, w11
		bl   _printf

		// Restore clobbered regs
		ldp x2, x3, [sp], #16
		ldp x0, x1, [sp], #16

	.Lskip_scratch_rms:
	.endif

	// ----- RMS DEBUG -----
	.if 0
	    // Save x0–x3 into unused area of 128-byte fixed frame (keeps sp constant)
	    stp x0, x1, [x29, #96]
	    stp x2, x3, [x29, #112]

	    mov x0, x17                       // L buffer pointer
	    mov x1, x18                       // R buffer pointer
	    mov w2, w11                       // num_frames this slice
	    bl _generator_compute_rms_asm     // s0 = RMS (float)

	    // Store RMS for real-time visual feedback  
	    adrp x9, _g_block_rms@PAGE
	    add  x9, x9, _g_block_rms@PAGEOFF
	    fmov s1, #0.5                     // Fixed RMS for visuals
	    str  s1, [x9]                     // g_block_rms = 0.5 (safe)

	    // Print raw IEEE bits so we avoid float formatting overhead
	    fmov w1, s0                       // RMS bits → w1
	    adrp x0, .Ldbg_rms_fmt@PAGE       // format string "%u\n"
	    add  x0, x0, .Ldbg_rms_fmt@PAGEOFF
	    bl  _printf

	    // Restore x0–x3
	    ldp x2, x3, [x29, #112]
	    ldp x0, x1, [x29, #96]
	.endif
	// ----- END RMS DEBUG -----

	// DEBUG PRINT BEGIN
.if 0
	stp x21, x22, [sp, #-16]!        // save frames_rem and spare callee-saved slot
	stp x8, x11, [sp, #-16]!         // save live regs for printf args
	adrp x0, .Ldbg_fmt@PAGE
	add  x0, x0, .Ldbg_fmt@PAGEOFF
	mov  w1, w21  // frames_rem
	mov  w2, w11  // frames_to_process
	mov  w3, w8   // pos_in_step
	bl   _printf
	ldp x8, x11, [sp], #16           // restore
	ldp x21, x22, [sp], #16          // restore frames_rem
.endif
	// DEBUG PRINT END

	// Advance counters
	add w8, w8, w11              // pos_in_step += frames_to_process
    // write back updated pos_in_step to struct
    add x10, x24, #0x1000
    add x10, x10, #0x128   // correct base for event/state block (g + 4392)
    str w8, [x10, #8]
	sub w21, w21, w11            // frames_rem  -= frames_to_process
	add w23, w23, w11            // frames_done += frames_to_process

	// Check if step boundary reached
	cmp w8, w9
	b.lt .Lgp_loop

	// Boundary reached – reset pos_in_step and advance step
	mov w8, wzr
	// Recompute event/state base pointer again (x10 may be clobbered by helpers)
	add x10, x24, #0x1000
	add x10, x10, #0x128   // x10 = &g->event_idx
	str w8, [x10, #8]       // write back pos_in_step = 0 to generator struct
	ldr w12, [x10, #4]        // w12 = step (event base + 4)
	add w12, w12, #1
	cmp w12, w13
	b.lt 3f
	mov w12, wzr
	str wzr, [x10]            // event_idx reset
3:	str w12, [x10, #4]
	b .Lgp_loop

.Lgp_after_loop:
	// Store updated pos_in_step back
	str w8, [x10, #8]

	// Deallocate scratch (free)
	mov x0, x25
	bl _free

	// TEMP: Skip delay & limiter to test if they're clearing audio
	b .Lgp_epilogue

	// ---------------------------------------------------------------------
	// Slice-5: Apply Delay & Limiter (C implementations)
	// --------------------------------------------------
	// delay_process_block(&g->delay, L, R, num_frames, 0.45f);
	// limiter_process(&g->limiter, L, R, num_frames);

	// Prepare arguments for delay_process_block
	// x24 = g (preserved), x19 = L buffer, x20 = R buffer, w23 = total num_frames

	// x0 = &g->delay  (offset 4408 bytes)
	add x0, x24, #4096        // base offset
	add x0, x0, #312          // 4096 + 312 = 4408
	mov x1, x19               // L
	mov x2, x20               // R
	mov w3, w23               // n = num_frames
	// s0 = 0.45f  (IEEE-754 0x3EE66666)
	mov w4, #0x6666
	movk w4, #0x3EE6, lsl #16
	fmov s0, w4
	bl _delay_process_block

    #ifndef SKIP_LIMITER
    // Prepare arguments for limiter_process
    // x0 = &g->limiter (offset 4424 bytes)
    add x0, x24, #4096        // base offset
    add x0, x0, #328          // 4096 + 328 = 4424
    mov x1, x19               // L
    mov x2, x20               // R
    mov w3, w23               // n = num_frames
    bl _limiter_process
    #endif

	// Existing epilogue label below handles register restore and return

.Lgp_epilogue:
	// Early-exit path: deallocate scratch skipped (not allocated)
	ldp x27, x28, [x29, #80]
	ldp x25, x26, [x29, #64]
	ldp x23, x24, [x29, #48]
	ldp x21, x22, [x29, #32]
	ldp x19, x20, [x29, #16]
	ldp x29, x30, [sp], #128    // pop full 128-byte frame
	ret

/*
 * generator_mix_buffers_asm - NEON vectorized buffer mixing
 * -------------------------------------------------------
 * void generator_mix_buffers_asm(float *L, float *R, 
 *                                 const float *Ld, const float *Rd,
 *                                 const float *Ls, const float *Rs,
 *                                 uint32_t num_frames);
 *
 * Performs: L[i] = Ld[i] + Ls[i]  (drums + synths)
 *          R[i] = Rd[i] + Rs[i]  (drums + synths)
 *
 * Uses NEON to process 4 samples per iteration for maximum throughput.
 * This is the hot path that runs every audio frame in real-time.
 */

_generator_mix_buffers_asm:
	// Arguments: x0=L, x1=R, x2=Ld, x3=Rd, x4=Ls, x5=Rs, w6=num_frames
	
	// TEMP: Check for zero frame count (common cause of silent exit)
	cbnz w6, .Lmix_continue
	ret  // Exit immediately if zero frames - but this is normal
.Lmix_continue:
	
	// Early exit if no frames to process
	cbz w6, .Lmix_done
	
	// Calculate how many complete NEON vectors (4 samples) we can process
	lsr w7, w6, #2          // w7 = num_frames / 4 (complete vectors)
	and w8, w6, #3          // w8 = num_frames % 4 (remainder samples)
	
	// Process complete 4-sample vectors with NEON
	cbz w7, .Lmix_scalar    // Skip if no complete vectors
	
.Lmix_vector_loop:
	// Load 4 samples from each source buffer
	ld1 {v0.4s}, [x2], #16  // v0 = Ld[i..i+3], advance pointer
	ld1 {v1.4s}, [x3], #16  // v1 = Rd[i..i+3], advance pointer  
	ld1 {v2.4s}, [x4], #16  // v2 = Ls[i..i+3], advance pointer
	ld1 {v3.4s}, [x5], #16  // v3 = Rs[i..i+3], advance pointer
	
	// Vector addition: drums + synths
	fadd v4.4s, v0.4s, v2.4s  // v4 = Ld + Ls
	fadd v5.4s, v1.4s, v3.4s  // v5 = Rd + Rs
	
	// Store results to output buffers
	st1 {v4.4s}, [x0], #16   // L[i..i+3] = v4, advance pointer
	st1 {v5.4s}, [x1], #16   // R[i..i+3] = v5, advance pointer
	
	// Loop control
	subs w7, w7, #1
	b.ne .Lmix_vector_loop
	
.Lmix_scalar:
	// Handle remaining samples (0-3) with scalar operations
	cbz w8, .Lmix_done
	
.Lmix_scalar_loop:
	// Load single samples
	ldr s0, [x2], #4        // s0 = Ld[i]
	ldr s1, [x3], #4        // s1 = Rd[i]
	ldr s2, [x4], #4        // s2 = Ls[i]
	ldr s3, [x5], #4        // s3 = Rs[i]
	
	// Scalar addition
	fadd s4, s0, s2         // s4 = Ld[i] + Ls[i]
	fadd s5, s1, s3         // s5 = Rd[i] + Rs[i]
	
	// Store results
	str s4, [x0], #4        // L[i] = s4
	str s5, [x1], #4        // R[i] = s5
	
	// Loop control
	subs w8, w8, #1
	b.ne .Lmix_scalar_loop
	
.Lmix_done:
	ret

.Lmix_null_error:
	// Safe debug message for NULL pointer error
	stp x0, x1, [sp, #-16]!   
	adrp x0, .Lmix_null_msg@PAGE
	add x0, x0, .Lmix_null_msg@PAGEOFF
	mov w1, #22
	mov x2, #2  // stderr
	mov x16, #4  // sys_write
	svc #0x80
	ldp x0, x1, [sp], #16
	ret

/*
 * generator_compute_rms_asm - NEON vectorized RMS calculation
 * ---------------------------------------------------------
 * float generator_compute_rms_asm(const float *L, const float *R, uint32_t num_frames);
 *
 * Computes RMS = sqrt(sum(L[i]² + R[i]²) / (num_frames * 2))
 * 
 * Uses NEON to process 4 samples per iteration:
 * - Load L[i..i+3] and R[i..i+3] 
 * - Square each (fmul)
 * - Add L² + R² (fadd)
 * - Accumulate in vector sum
 * - Final horizontal sum + sqrt in scalar
 */

	.globl _generator_compute_rms_asm

_generator_compute_rms_asm:
	// Arguments: x0=L, x1=R, w2=num_frames
	// Returns: s0 = RMS value
	
	// Early exit if no frames
	cbz w2, .Lrms_zero
	
	// Initialize accumulator vector to zero
	movi v16.4s, #0              // v16 = accumulator for vector sum
	fmov s17, wzr                // s17 = accumulator for scalar sum
	
	// Calculate how many complete NEON vectors (4 samples) we can process
	lsr w3, w2, #2               // w3 = num_frames / 4 (complete vectors)
	and w4, w2, #3               // w4 = num_frames % 4 (remainder samples)
	
	// Process complete 4-sample vectors with NEON
	cbz w3, .Lrms_scalar         // Skip if no complete vectors
	
.Lrms_vector_loop:
	// Load 4 samples from each buffer
	ld1 {v0.4s}, [x0], #16       // v0 = L[i..i+3], advance pointer
	ld1 {v1.4s}, [x1], #16       // v1 = R[i..i+3], advance pointer
	
	// Square the samples: L² and R²
	fmul v2.4s, v0.4s, v0.4s     // v2 = L[i]² for 4 samples
	fmul v3.4s, v1.4s, v1.4s     // v3 = R[i]² for 4 samples
	
	// Add L² + R² 
	fadd v4.4s, v2.4s, v3.4s     // v4 = L[i]² + R[i]² for 4 samples
	
	// Accumulate in sum vector
	fadd v16.4s, v16.4s, v4.4s   // accumulate
	
	// Loop control
	subs w3, w3, #1
	b.ne .Lrms_vector_loop
	
.Lrms_scalar:
	// Handle remaining samples (0-3) with scalar operations
	cbz w4, .Lrms_finalize
	
.Lrms_scalar_loop:
	// Load single samples
	ldr s0, [x0], #4             // s0 = L[i]
	ldr s1, [x1], #4             // s1 = R[i]
	
	// Square and add: L² + R²
	fmul s2, s0, s0              // s2 = L[i]²
	fmul s3, s1, s1              // s3 = R[i]²
	fadd s4, s2, s3              // s4 = L[i]² + R[i]²
	
	// Add to scalar accumulator  
	fadd s17, s17, s4            // accumulate scalar remainder
	
	// Loop control
	subs w4, w4, #1
	b.ne .Lrms_scalar_loop
	
.Lrms_finalize:
	// Horizontal sum of accumulator vector v16 → s0
	faddp v18.4s, v16.4s, v16.4s // pairwise add: [a+b, c+d, a+b, c+d]
	faddp s0, v18.2s             // final vector sum: (a+b) + (c+d)
	
	// Add scalar accumulator to vector sum
	fadd s0, s0, s17             // total_sum = vector_sum + scalar_sum
	
	// Convert num_frames to float and multiply by 2
	ucvtf s1, w2                 // s1 = (float)num_frames  
	fmov s2, #2.0                // s2 = 2.0
	fmul s1, s1, s2              // s1 = num_frames * 2
	
	// Divide sum by (num_frames * 2) to get mean
	fdiv s0, s0, s1              // s0 = mean = sum / (num_frames * 2)
	
	// Take square root to get RMS
	fsqrt s0, s0                 // s0 = sqrt(mean) = RMS
	
	ret
	
.Lrms_zero:
	// Return 0.0 if no frames
	fmov s0, wzr
	ret 

/*
 * generator_clear_buffers_asm - NEON vectorized buffer clearing
 * -----------------------------------------------------------
 * void generator_clear_buffers_asm(float *Ld, float *Rd, float *Ls, float *Rs, uint32_t num_frames);
 *
 * Clears (zeros) all 4 float buffers using NEON vector stores.
 * Replaces 4 memset() calls with optimized NEON operations.
 * 
 * Uses NEON to process 4 samples per iteration for maximum throughput.
 */

	.globl _generator_clear_buffers_asm

_generator_clear_buffers_asm:
	// Arguments: x0=Ld, x1=Rd, x2=Ls, x3=Rs, w4=num_frames
	
	// Early exit if no frames to process
	cbz w4, .Lclear_done
	
	// Initialize zero vector for NEON stores
	movi v0.4s, #0               // v0 = [0.0, 0.0, 0.0, 0.0]
	
	// Calculate how many complete NEON vectors (4 samples) we can process
	lsr w5, w4, #2               // w5 = num_frames / 4 (complete vectors)
	and w6, w4, #3               // w6 = num_frames % 4 (remainder samples)
	
	// Process complete 4-sample vectors with NEON
	cbz w5, .Lclear_scalar       // Skip if no complete vectors
	
.Lclear_vector_loop:
	// Store 4 zero samples to each buffer
	st1 {v0.4s}, [x0], #16       // Ld[i..i+3] = 0.0, advance pointer
	st1 {v0.4s}, [x1], #16       // Rd[i..i+3] = 0.0, advance pointer  
	st1 {v0.4s}, [x2], #16       // Ls[i..i+3] = 0.0, advance pointer
	st1 {v0.4s}, [x3], #16       // Rs[i..i+3] = 0.0, advance pointer
	
	// Loop control
	subs w5, w5, #1
	b.ne .Lclear_vector_loop
	
.Lclear_scalar:
	// Handle remaining samples (0-3) with scalar operations
	cbz w6, .Lclear_done
	
	// Zero value for scalar stores
	fmov s1, wzr                 // s1 = 0.0
	
.Lclear_scalar_loop:
	// Store single zero sample to each buffer
	str s1, [x0], #4             // Ld[i] = 0.0
	str s1, [x1], #4             // Rd[i] = 0.0
	str s1, [x2], #4             // Ls[i] = 0.0  
	str s1, [x3], #4             // Rs[i] = 0.0
	
	// Loop control
	subs w6, w6, #1
	b.ne .Lclear_scalar_loop
	
.Lclear_done:
	ret

/*
 * generator_rotate_pattern_asm - NEON vectorized pattern rotation
 * -------------------------------------------------------------
 * void generator_rotate_pattern_asm(uint8_t *pattern, uint8_t *tmp, uint32_t size, uint32_t rot);
 *
 * Rotates a uint8_t array by 'rot' positions: pattern[i] = old_pattern[(i+rot) % size]
 * Optimized for size=16 (STEPS_PER_BAR) using NEON EXT instruction.
 * 
 * For size=16: Single NEON register holds entire pattern, EXT performs rotation in one operation.
 */

	.globl _generator_rotate_pattern_asm

_generator_rotate_pattern_asm:
	// Arguments: x0=pattern, x1=tmp, w2=size, w3=rot
	
	// Early exit if no rotation needed
	cbz w3, .Lrot_done
	
	// Optimize for STEPS_PER_BAR =